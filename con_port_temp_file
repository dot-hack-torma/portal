#!/bin/bash
declare -g script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 || exit ; pwd -P )"
# shellcheck disable=1090,2034,2154,2155,2235

# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
#
function load_config_file {
   # Check if a change in the configfile path is not already changed, if it is
   #     use that value, if it isn't, we 
   path_to_config_file=${PORTAL_CONFIG_FILEPATH:-"/home/$(whoami)/.portal/.config"}

   if ! [[ -f "${path_to_config_file}" ]]; then
      echo "Config file does not exist, proceeding with default values, some things may not work as intended"
      echo "If you wish to create a default config file to edit, please run the script with the \"--init\" flag"
      return 1
   fi

   source "${path_to_config_file}"

   if [[ -n "${data_files_location}" ]] && [[ -d ${data_files_location} ]]; then
      PATHS_FOR_DATAFILES="${data_files_location}"
   elif [[ -n "${PATHS_FOR_DATAFILES}" ]]; then
      :
   else
      echo "Cannot set \"${data_files_location}\" as data files dir, no directory found"
      exit 1
   fi

   if [[ -n "${browser}" ]]; then
      if command -v "${browser}" >/dev/null 2>&1; then
         case ${browser} in 
            vivaldi)
               declare -g BROWSER_NEW_TAB_METHOD="vivaldi --parent-window"
               ;;

            chrome)
               declare -g BROWSER_NEW_TAB_METHOD="google-chrome --new-window"
               ;;

            firefox)
               declare -g BROWSER_NEW_TAB_METHOD="firefox --new-window"
               ;;

            *)
               echo  "Unsupported browser, exiting"
               exit 1
               ;;
         esac
      fi
   else
      declare -g BROWSER_NEW_TAB_METHOD="echo"
      echo "Browser not set, will not be able to start any http connections."
   fi

   if [[ -n "${infinite_loop}" ]] && ( [[ "${infinite_loop}" == "true" ]] || [[ "${infinite_loop}" == "false" ]] ); then
      endless_loop="${infinite_loop}"
   fi

   # Check if variable exists and if variable is a number, and to quote from a 
   #     source: "Basically any numeric value evaluation operations using 
   #     non-numbers will result in an error which will be implicitly 
   #     considered as false in shell"
   if [[ -n "${page_size}" ]] && [[ "${page_size}" -eq "${page_size}" ]]; then
      PAGE_SIZE=${page_size}
   fi

}

# Get a list of all the .csv files we wish to read
function get_list_of_csv_files {
   for path in "${PATHS_FOR_DATAFILES[@]}"; do
      if ! [[ -d "${path}" ]]; then
         echo "Exiting, dir to .csv files not found: ${path}"
         echo "   Create the directory and populate with .csv files"
         echo "   or double check the configuration for the correct"
         echo "   .csv files location"
         exit 1
      fi

      while read -r file; do
         set_of_csv_files+=( "${file}" )
      done < <(find "${path}" -type f -iname "*.csv")
   done
}

# Load header of .csv file, so we know the key values by which we can sort and 
#     interact with. I've adjusted it like this so it's adaptable for future
#     additions of keywords.
function load_key_values {
   local KEY_VALUES="$(awk "NR==1{print}" "${set_of_csv_files[0]}")"

   iterator=0; old_IFS=${IFS}; IFS=" "
   for key_value in ${KEY_VALUES//,/ }; do
      ((iterator++))
      eval serverlistKeyArray[${iterator}]="${key_value}"
   done; IFS="${old_IFS}"
}

# Load all of the values from the supplied .csv files into memory (array)
function load_csv_file_values {
   iterator=0; old_IFS=${IFS}; IFS=","
   for file in "${set_of_csv_files[@]}"; do
      { 
         # Ignore first entry as that is the header of the .csv file.
         read -r
         while read -r item; do

            # We ignore any commented out values
            if [[ "${item}" == "#"* ]]; then continue; fi
            
            iterator=0
            for key_value in ${item}; do
               if [[ ${iterator} == 0 ]]; then entry_name="${key_value}"; fi

               ((iterator++))
               serverlistArray[${entry_name},${serverlistKeyArray[${iterator}]}]="${key_value}"
            done
         done 

         
      } < "${file}"
   done

   IFS="${old_IFS}"
}

# Load all menu items (each of the entries in the .csv file) into memory, so 
#     we can list them within the menu.
#
# Note: We can add different types of sorting from within this menu, currently, 
#     it's only sorted by name, but we could add by category (which I'm 
#     currently implementing slowly...)
function load_menu_items {
   readarray -t serverlistMenuItems < <(for each in "${!serverlistArray[@]}"; do echo -e "${each//,*/}"; done | sort -n | uniq)

   # for each in "${!serverlistArray[@]}"; do echo -e "${serverlistArray[${each//,*/},protocol]}:${each//,*/} ${serverlistArray[${each//,*/},protocol]}"; done

   #for each in "${!serverlistArray[@]}"; do echo -e "${each//,*/} ${serverlistArray[${each//,*/},protocol]}"; done | sort -t ' ' -k2h,1 -k1h,2 

   # readarray -t serverlistMenuItems < <(for each in "${!serverlistArray[@]}"; do echo -e "${serverlistArray[${each//,*/},protocol]}:${each//,*/} ${serverlistArray[${each//,*/},protocol]}"; done | sort -t ' ' -k2h,1 -k1h,2 | uniq | cut -d' ' -f1)
}
# shellcheck disable=1090,2034,2154,2155

# ██╗   ██╗ █████╗ ██████╗ ██╗ █████╗ ██████╗ ██╗     ███████╗███████╗
# ██║   ██║██╔══██╗██╔══██╗██║██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
# ██║   ██║███████║██████╔╝██║███████║██████╔╝██║     █████╗  ███████╗
# ╚██╗ ██╔╝██╔══██║██╔══██╗██║██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
#  ╚████╔╝ ██║  ██║██║  ██║██║██║  ██║██████╔╝███████╗███████╗███████║
#   ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝
# NECESSARY FILES
#declare -g AUTOINSERT_PASSWORD_EXPECT_SCRIPT="${script_path}/functions/supply_pass.exp"
declare -g PATHS_FOR_DATAFILES=( "/home/$(whoami)/.portal/data" )
declare -g set_of_csv_files=()

# PREFERRED BROWSER
declare -g BROWSER_NEW_TAB_METHOD="vivaldi --parent-window"

# DATA ARRAYS
declare -Ag serverlistKeyArray
declare -Ag serverlistArray

# POSITIONAL VARIABLES
declare -g FIRST_WIDTH_SETUP="true"
declare -g PAGE_SIZE="20"
declare -g y_cursor_position="0"
declare -g current_page="1"
declare -g loop_once="false"
declare -g skip_clear="true"
declare -g endless_loop="false"
declare -g gui_mode="false"
declare -g list_mode="false"
declare -g search_mode="false"
declare -g ignore_case="false"
declare -g search_keyword=""
declare -g is_initial_setup="false"
declare -g force_overwrite="false"

# COLOURS
declare -g CLR=$'\033[0m'
declare -g INVERT_COLOR=$'\033[1;7m'
declare -g GREEN=$'\033[1;38;5;118m'
declare -g RED=$'\033[1;38;5;198m'

# SORTED VALUES FOR NICE DRAWING OF CONNECTION DETAILS
declare -g serverlistKeyArraySorted=( "entry_name" "hostname" "ip_address" "port" "username" "protocol" "note" )
# shellcheck disable=1090,2034,2154,2155

# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
function draw_top_divider {
   draw_divider "╔" "═" "╗"
}

function draw_mid_divider {
   draw_divider "╠" "═" "╣"
}

function draw_bot_divider {
   draw_divider "╚" "═" "╝"
}

function draw_divider {
   divider_starter=${1}
   divider_symbol=${2}
   divider_end=${3}

   printf "%s" "${divider_starter}"
   eval "printf '${divider_symbol}%.0s' {1..${divider_inner_menu_width}}"
   printf "%s\n" "${divider_end}"
}

function draw_line {
   input_string=${1}

   printf "║ %-${inner_menu_width}s ║\n" "${input_string}"
}

function draw_line_set_length {
   input_string=${1}
   length=${2}
   true_inner_width=$((inner_menu_width+length))

   printf "║ %-${true_inner_width}s ║\n" "${input_string}"
}

function draw_line_colour_set_length_align_right {
   input_string=${1}
   length=${2}
   true_inner_width=$((inner_menu_width+length))

   printf "║ %${true_inner_width}s ║\n" "${input_string}"
}

function draw_line_mid_align {
   local input_string=${1}

   local raw_input_string="$(echo "${input_string}" | sed -u -e 's/\[[0-9;]*m//g' -e 's/\x1b//g')"
   local input_string_length=${#raw_input_string}
   local symetrical_split_for_mid_align_width=$((((((divider_inner_menu_width-input_string_length))/2))-1))

   mid_align_whitespace=$(eval printf '\ %.0s' "{1..${symetrical_split_for_mid_align_width}}")
   additional_space=""

   if [[ $((((((${#mid_align_whitespace}*2))+input_string_length))+4)) -ne ${terminal_width} ]]; then additional_space=" "; fi

   printf "║ %s%-${input_string_length}s%s%s ║\n" "${mid_align_whitespace}" "${input_string}" "${mid_align_whitespace}" "${additional_space}"
}

function print_help_menu {
   echo "Usage: ./$(basename "${0}") [http|ssh|sftp|--gui].."
   echo "Script is used to have a set of predetermined connections set up via .csv files, "
   echo "and then use the gui or supplied arguments to connect to the specificed connections."
   echo 
   echo "General script output arguments"
   echo "   -g, --gui                       enables gui menu for choosing a portal connection"
   echo "   http|ssh|sftp [ARG]             connects using one of the supplied protocols"
   echo "                    ^              ARG refers to the entry_id that is needed for a connection"
   echo
   echo "   -s, --search                    search (with grep) through the list of existing connections"
   echo "   -si, --search-case-insensitive                 search (with grep) through the list of existing connections"
   echo "   -l, --list                      print all portal connections in a table onto stdout"
   echo "   -b, --bash-completion           source the bash completion file, which updates the bash"
   echo "                                    completion for any additional new data in the .csv files"
   echo "   -i, --init                      create initial .config and bash completion file (by default"
   echo "                                    located in /home/\$(whoami)/.portal directory)"
   echo "   -f, --force                     used in conjunction with --init, it forces an overwrite of"
   echo "                                    the .config and bash completion files, in other words"
   echo "                                    reinitialize them"
   echo 
   echo "Command usage examples"
   echo "./$(basename "${0}") --gui"
   echo "./$(basename "${0}") --list"
   echo "./$(basename "${0}") --search kubernetes"
   echo "./$(basename "${0}") http cicd_cluster_1"
}

function draw_menu {
   local input_menu="${1}"

   update_width

   case ${input_menu} in
      main)
         if ! ${loop_once}; then
            draw_top_divider
            draw_line_mid_align "  .,--+ ${SCRIPT_NAME} -- ${VERSION} +--,.  "
            draw_mid_divider
         else
            echo -e "\e[3;0f"
         fi

         # Adjust settings in regards to pages.
         current_page_adjuted_for_calculating=$((current_page-1))
         page_offset=$((current_page_adjuted_for_calculating*PAGE_SIZE))
         readjusted_y_position_according_to_page_number=$(($((y_cursor_position%PAGE_SIZE))+page_offset))
         page_end_offset=$((page_offset+((PAGE_SIZE-1))))
         
         old_IFS=${IFS}; IFS=" ";
         iterate_array=$(IFS= ; eval echo "{${page_offset}..${page_end_offset}}")
         for iterator in ${iterate_array}; do
               local selection="${serverlistMenuItems[${readjusted_y_position_according_to_page_number}]}"

               if [[ ${readjusted_y_position_according_to_page_number} -eq ${iterator} ]]; then 
                  draw_line_set_length " > ${GREEN}${INVERT_COLOR} $(printf "%-4s" "${serverlistArray[${selection},protocol]}") ${CLR} ${INVERT_COLOR} ${selection} ${CLR} " "33"
               elif [[ ${serverlistMenuItems[${iterator}]} != "" ]]; then
                  draw_line_set_length "   $(printf "[%-4s] %s" "${serverlistArray[${serverlistMenuItems[${iterator}]},protocol]}" "${serverlistArray[${serverlistMenuItems[${iterator}]},entry_name]}") " ""
               else
                  draw_line ""
               fi    
         done
         ;;
   esac

   half_inner_menu_width=$((inner_menu_width/2))
   if [[ ${serverlistArray[${selection},protocol]} == "ssh" ]] || [[ ${serverlistArray[${selection},protocol]} == "sftp" ]]; then
      adjusted_info_hostname="${GREEN}${serverlistArray[${selection},hostname]}${INVERT_COLOR}${CLR}:${GREEN}${serverlistArray[${selection},port]}${CLR}"
      add_char_length="40"
   elif [[ ${#serverlistArray[${selection},hostname]} -gt "${half_inner_menu_width}" ]]; then
      adjusted_info_hostname="${GREEN}$(echo "$(echo "${serverlistArray[${selection},hostname]}" | cut -c1-${half_inner_menu_width})"\(...\))${CLR}"
      add_char_length="17"
   else
      adjusted_info_hostname="${GREEN}${serverlistArray[${selection},hostname]}${CLR}"
      add_char_length="17"
   fi


   draw_line ""
   draw_line_colour_set_length_align_right " Page: [ ${INVERT_COLOR} ${current_page} ${CLR} / ${number_of_pages} ] " "10"
      draw_mid_divider
   draw_line_colour_set_length_align_right "[${serverlistArray[${selection},entry_name]}] // ${adjusted_info_hostname}" "${add_char_length}"
   draw_line_colour_set_length_align_right "Category: ${GREEN}${serverlistArray[${selection},category]}${CLR} // Protocol: ${GREEN}${serverlistArray[${selection},protocol]}${CLR}" "34"

   if ! [[ "${serverlistArray[${selection},note]}" == "NONE" ]]; then
      draw_line_colour_set_length_align_right "Note: ${GREEN}${serverlistArray[${selection},note]}${CLR}" "17"
   else
      draw_line
   fi

   # DISPLAYS CURRENTLY SET CONTROLS, COMMENTED OUT FOR NOW, MAYBE READDING LATER
   # draw_mid_divider
   # draw_line_mid_align " Up: [${INVERT_COLOR} w / Arrow Up ${CLR}] | Down: [${INVERT_COLOR} s / Arrow Down ${CLR}]"
   # draw_line_mid_align " Confirm: [${INVERT_COLOR} j / Enter ${CLR}] "
   draw_bot_divider

   # DEBUGGING FOR TERMINAL DRAWING THINGIES
   # echo "page_end_offset: ${page_end_offset}; page_offset: ${page_offset}    "
   # echo "PAGE_SIZE: ${PAGE_SIZE}; current_page: ${current_page}   "
   # echo "current_page_adjuted_for_calculating: ${current_page_adjuted_for_calculating}  ; readjusted_y_position_according_to_page_number: ${readjusted_y_position_according_to_page_number}    "
   # echo "y_cursor_position: ${y_cursor_position}    "
   # echo "number_of_pages: ${number_of_pages}    "
   # echo "size of serverlistArray[@]: ${#serverlistArray[@]}     "
   # echo "size of: serverlistMenuItems: ${#serverlistMenuItems[@]}     "
   # echo "terminal_width: ${terminal_width}"
}

function determine_longest_string_in_array_by_keyword {
   local keyword="${1}"
   local longest_string="${#keyword}"
   local iterator="0"
   
   for each in "${serverlistMenuItems[@]}"; do 
      if [[ "${#serverlistArray[${serverlistMenuItems[${iterator}]},${keyword}]}" -gt "${longest_string}" ]]; then 
         longest_string="${#serverlistArray[${serverlistMenuItems[${iterator}]},${keyword}]}"; 
      fi
      ((iterator++))
   done

   echo "${longest_string}"
}

function draw_connection_list {
   
   # longest_string="0"
   # local iterator="0"; for each in "${serverlistMenuItems[@]}"; do 
   #    if [[ "${#serverlistArray[${serverlistMenuItems[${iterator}]},entry_name]}" -gt "${longest_string}" ]]; then 
   #       longest_string="${#serverlistArray[${serverlistMenuItems[${iterator}]},entry_name]}"; 
   #    fi
   #    ((iterator++))
   # done

   if "${search_mode}"; then
      if [[ -z "${search_keyword}" ]]; then 
         echo "Error: empty search string, exiting"; exit 1
      fi

      grep_extra_arguments="--color"
      search_command="${search_keyword}"

      if "${ignore_case}"; then
         grep_extra_arguments="${grep_extra_arguments} -i"
      fi
   else
      grep_extra_arguments="--color=never"
      search_command="."
   fi

   list_keywords=( "short_key_id" "entry_name" "category" "ip_address" "protocol" "username" "password" "note" )
   for each in "${list_keywords[@]}"; do
      eval longest_"${each}"_string="$(determine_longest_string_in_array_by_keyword "${each}")"
   done

   short_key_id_print="$(eval "printf '─%.0s' {-1..$((longest_short_key_id_string))}")"
   entry_name_print="$(eval "printf '─%.0s' {-1..$((longest_entry_name_string))}")"
   category_print="$(eval "printf '─%.0s' {-1..$((longest_category_string))}")"
   ip_address_print="$(eval "printf '─%.0s' {-1..$((longest_ip_address_string))}")"
   protocol_print="$(eval "printf '─%.0s' {-1..$((longest_protocol_string))}")"
   username_print="$(eval "printf '─%.0s' {-1..$((longest_username_string))}")"
   password_print="$(eval "printf '─%.0s' {-1..$((longest_password_string))}")"
   note_print="$(eval "printf '─%.0s' {-1..$((longest_note_string))}")"
   iterator="0"


   printf "┌%s┬%s┬%s┬%s┬%s┬%s┬%s┬%s┐\n" "${short_key_id_print}" "${entry_name_print}" "${category_print}" "${ip_address_print}" "${protocol_print}" "${username_print}" "${password_print}" "${note_print}"

   printf "│ %-${longest_short_key_id_string}s │ %-${longest_entry_name_string}s │ %-${longest_category_string}s │ %-${longest_ip_address_string}s │ %-${longest_protocol_string}s │ %-${longest_username_string}s │ %-${longest_password_string}s │ %-${longest_note_string}s │\n" \
         "short_key_id" \
         "entry_name" \
         "category" \
         "ip_address" \
         "protocol" \
         "username" \
         "password" \
         "note"

   printf "├%s┼%s┼%s┼%s┼%s┼%s┼%s┼%s┤\n" "${short_key_id_print}" "${entry_name_print}" "${category_print}" "${ip_address_print}" "${protocol_print}" "${username_print}" "${password_print}" "${note_print}"
 
   for each in "${serverlistMenuItems[@]}"; do
      printf "│ %-${longest_short_key_id_string}s │ %-${longest_entry_name_string}s │ %-${longest_category_string}s │ %-${longest_ip_address_string}s │ %-${longest_protocol_string}s │ %-${longest_username_string}s │ %-${longest_password_string}s │ %-${longest_note_string}s │\n" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},short_key_id]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},entry_name]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},category]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},ip_address]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},protocol]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},username]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},password]}" \
         "${serverlistArray[${serverlistMenuItems[${iterator}]},note]}"

      ((iterator++))
   done | sort -t '|' -k2,2 -k3,3r | grep ${grep_extra_arguments} "${search_command}"

   printf "└%s┴%s┴%s┴%s┴%s┴%s┴%s┴%s┘\n" "${short_key_id_print}" "${entry_name_print}" "${category_print}" "${ip_address_print}" "${protocol_print}" "${username_print}" "${password_print}" "${note_print}"
}

function fake_loading_screen {
   for iterator in {1..5}; do
      printf "\t Loading... "
      eval "printf '■%.0s' {1..$((iterator))}"
      if [[ ${iterator} -lt 5 ]]; then eval "printf '□%.0s' {1..$((5-iterator))}"; fi
      echo -e "\e[1A"
      eval "sleep 0.$(($((RANDOM%8))+1))"
      #sleep 0.4
   done
}
# shellcheck disable=1090,2034,2154,2155

# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
function update_width {
   if ${FIRST_WIDTH_SETUP}; then
      old_width="${terminal_width}"
      FIRST_WIDTH_SETUP="false"
   fi

   terminal_width="$(($(tput cols)/3))"

   # Make sure that the terminal is not too narrow and that the mid alignment 
   if [[ ${terminal_width} -lt 60 ]]; then terminal_width="60"; fi
   if [[ $((terminal_width%2)) -ne 0 ]]; then ((terminal_width--)); fi

   divider_inner_menu_width="$((terminal_width-2))"
   inner_menu_width="$((terminal_width-4))"

   if [[ ${old_width} -ne ${terminal_width} ]]; then
      loop_once="false"
      clear
      #echo djwioadjaw; sleep 2
   fi
   
   old_width="${terminal_width}"
}

function hide_input {
   stty -echo
   tput civis
}

function reenable_input {
   stty echo
   tput cnorm
}

function expect_ssh_connection {
   expect -c "
   set timeout 20
   spawn ssh ${serverlistArray[${menu_selection},username]}@${serverlistArray[${menu_selection},hostname]} -p ${serverlistArray[${menu_selection},port]}
   expect \"*?assword\" { send \"${serverlistArray[${menu_selection},password]}\r\" }
   interact
   "
}

# Create initial default configuration file for this script to work, and add 
#     the bash completion to it. Afterwards source it to have the completion in place
function initial_setup {
   path_to_config_file=${PORTAL_CONFIG_FILEPATH:-"/home/$(whoami)/.portal/.config"}

   if ! [[ -d "/home/$(whoami)/.portal/" ]]; then
      mkdir -pv "/home/$(whoami)/.portal/" || 
         echo "Unable to portal data location directory" 
   fi

   if [[ -f ${path_to_config_file} ]] && ! "${force_overwrite}"; then
      echo
      echo "Cannot perform initial setup, config file already found on path: ${path_to_config_file}"
      exit 1
   else
      :>"${path_to_config_file}"
      cat <<\EOF >> "${path_to_config_file}"
# Configuration file for the portal script, readjusting this file should
#     pre-set some values when starting portal without any additional 
#     explicit flags. Flags added to the script have precedent over this
#     configuration file.
#
# Define location of the .csv files from where the script will load the 
# data from. 
# Default: "/home/\$(whoami)/.portal/data" defined within the script
#data_files_location=""
#
# Define the default browser you are using in case the http protocol is
# used. Currently usable values are: chrome, firefox, vivaldi.
browser="vivaldi"
#
# Define whether the gui will loop within the menu infinitely or will 
# exit after the first connection is established. Values: true, false.
# Setting it to true will allow the script to loop infinitely until you
# explicitly CTRL+C out of the loop.
infinite_loop="flase"
#
# Define the number of entries allowed on each of the pages within the 
# gui mode. This is something that might be modular in the future, but
# at this point, it's statically set up, which is by default 20.
#page_size="20"
EOF
      echo
      echo "Created initial .config file at ${path_to_config_file}"
      echo "Please adjust the file in accordance to your needs and"
      echo "feel free to use the portal script now :)"
   fi



   path_to_bashcomplete_file=${PORTAL_BASH_COMPLETE_FILEPATH:-"/home/$(whoami)/.portal/portal-completion.bash"}
   if [[ -f ${path_to_bashcomplete_file} ]]  && ! "${force_overwrite}"; then
      echo
      echo "Bash completion file found and sourcing it at: ${path_to_bashcomplete_file}"
      bash_completion

   else

   :>"${path_to_bashcomplete_file}"
   cat <<\EOF >> "${path_to_bashcomplete_file}"

PATHS_FOR_DATAFILES=( "/home/$(whoami)/.portal/data" )

function portal_completions {
   local IFS=$'\n'
   local suggestions=($(compgen -W "$(cat ${PATHS_FOR_DATAFILES}/* | grep -v '^\#' | awk -v get='^protocol' 'BEGIN{FS=OFS=","}FNR==1{for(i=1;i<=NF;i++)if($i~get)cols[++c]=i}{for(i=1; i<=c; i++)printf "%s%s", $(cols[i]), (i<c ? OFS : ORS)}' | sort | uniq | grep -v protocol | grep .)" -- "${COMP_WORDS[1]}" ))

   if [[ "${#COMP_WORDS[@]}" -gt "3" ]]; then
      return
   elif [[ "${#COMP_WORDS[@]}" -gt "2" ]] && [[ "${COMP_WORDS[1]}" != "--gui" ]]; then
      local suggestions=($(compgen -W "$(cat ${PATHS_FOR_DATAFILES}/* | grep -v '^\#' | grep -E ",${COMP_WORDS[1]},|entry_name" | awk -v get='^entry_name' 'BEGIN{FS=OFS=","}FNR==1{for(i=1;i<=NF;i++)if($i~get)cols[++c]=i}{for(i=1; i<=c; i++)printf "%s%s", $(cols[i]), (i<c ? OFS : ORS)}' | sort | uniq | grep -v entry_name | grep .)" -- "${COMP_WORDS[2]}" ))
   elif [[ "${#COMP_WORDS[@]}" -gt "2" ]]; then
      return
   fi

   COMPREPLY=("${suggestions[@]}")
}

complete -F portal_completions portal
EOF

      echo
      echo "Created portal-completion.bash file and sourced it: ${path_to_bashcomplete_file}"
      echo "Bash completion should work now"
      bash_completion
   fi
}

function check_for_connection {
   if [[ -n "${serverlistArray[${menu_selection},entry_name]}" ]]; then
      return 0
   fi

   local old_selection=${menu_selection}
   local selection_found="false"
   local iterator=0
   for each in "${serverlistMenuItems[@]}"; do 
      if [[ "${serverlistArray[${serverlistMenuItems[${iterator}]},short_key_id]}" == "${menu_selection}" ]]; then 
         menu_selection="${serverlistArray[${serverlistMenuItems[${iterator}]},entry_name]}"
         selection_found="true"
         break
      fi
      ((iterator++))
   done

   if ${selection_found}; then
      echo "Found connection with unique keyword ${GREEN}${old_selection}${CLR}: ${GREEN}${menu_selection}${CLR}"
      echo "Proceeding with connection..."
   else
      echo "Error: no connection like that (${RED}${menu_selection}${CLR}) found, exiting."; exit 1
   fi
}

function bash_completion {
   path_to_bashcomplete_file=${PORTAL_BASH_COMPLETE_FILEPATH:-"/home/$(whoami)/.portal/portal-completion.bash"}

   if [[ -f "${path_to_bashcomplete_file}" ]]; then
      echo "File to source found, please source file or add the source command to your .bashrc file. Examples:"
      echo
      echo "source ${path_to_bashcomplete_file}"
      echo "echo \"source ${path_to_bashcomplete_file}\" >> /home/$(whoami)/.bashrc"
   else
      echo "Cannot find bash completion file, exiting "
   fi
}

# ████████╗██████╗  █████╗ ██████╗ 
# ╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗
#    ██║   ██████╔╝███████║██████╔╝
#    ██║   ██╔══██╗██╔══██║██╔═══╝ 
#    ██║   ██║  ██║██║  ██║██║     
#    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     

# Reset terminal to current state when we exit.
trap reenable_input EXIT

# shellcheck disable=1090,2034,2154,2155

# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝
function menu_movement {
   local input_menu="${1}"

   menu_item_count=${#serverlistMenuItems[@]}; ((menu_item_count--))

   while true; do
      wait_for_input

      if [[ -n ${key_stroke} ]]; then 
         case ${key_stroke} in
            "up") 
               ((y_cursor_position--))
               if [[ "${y_cursor_position}" -lt 0 ]]; then 
                  y_cursor_position=${menu_item_count}
                  current_page=${number_of_pages}
               fi

               if [[ $((y_cursor_position%PAGE_SIZE)) -eq $((PAGE_SIZE-1)) ]]; then 
                  ((current_page--))
                  if [[ ${current_page} -lt 1 ]]; then
                     current_page=1
                  fi
               fi

               loop_once="true"
               ;;

            "down") 
               ((y_cursor_position++))
               if [[ "${y_cursor_position}" -gt "${menu_item_count}" ]]; then 
                  y_cursor_position="0"
                  current_page=1
               fi

               if [[ $((y_cursor_position%PAGE_SIZE)) -eq 0 ]] && [[ ${y_cursor_position} -ne 0 ]]; then 
                  ((current_page++))
                  if [[ ${current_page} -gt $((current_page+1)) ]]; then
                     current_page=1
                  fi
               fi
               loop_once="true"
               ;;

            "page_up")
               ((current_page--))
               if [[ ${current_page} -lt 1 ]]; then
                  current_page=1
               fi

               y_cursor_position=$((y_cursor_position-PAGE_SIZE))
               if [[ "${y_cursor_position}" -lt 0 ]]; then 
                  y_cursor_position=0
                  current_page=1
               fi
               loop_once="true"
               ;;

            "page_down")
               ((current_page++))
               if [[ ${current_page} -gt $((number_of_pages+1)) ]]; then
                  current_page=1
               fi

               y_cursor_position=$((PAGE_SIZE+y_cursor_position))
               if [[ "${y_cursor_position}" -gt "${menu_item_count}" ]]; then 
                  y_cursor_position=${menu_item_count}
                  current_page=${number_of_pages}
               fi
               loop_once="true"
               ;;

            "right") 
               #echo "You pressed right"
               ;;
            "left") 
               #echo "You pressed left"
               ;;
            "confirm") 
               menu_selection=${serverlistMenuItems[${y_cursor_position}]//*:/}
               action="confirm"
               break
               ;;
            "cancel") 
               menu_selection=""
               action="cancel"
               break
               ;;
            "command") 
               #echo "You pressed COMMAND"
               ;;
         esac

         key_stroke="";
         if ! ${skip_clear}; then clear; loop_once="false"; skip_clear="true"; fi
         draw_menu "main"
      fi
   done
}

function main_menu {
   number_of_pages=$((${#serverlistMenuItems[@]}/PAGE_SIZE)); ((number_of_pages++))
   if [[ $((${#serverlistMenuItems[@]}%PAGE_SIZE)) -eq 0 ]]; then ((number_of_pages--)); fi

   clear; draw_menu main
   
   while true; do
      menu_movement "main"

      if [[ "${action}" == "confirm" ]]; then

         echo -e "\e[2A"
         draw_mid_divider
         #draw_line_set_length "Selected: ${INVERT_COLOR} ${menu_selection} ${CLR}" 10
         
         # for key_value in "${serverlistKeyArraySorted[@]}"; do
         #    if [[ -n "${serverlistArray[${menu_selection},${key_value}]}" ]]; then
         #       draw_line_set_length "  ${GREEN}${key_value}${CLR}: ${serverlistArray[${menu_selection},${key_value}]}" "17"
         #    fi
         # done

         do_action "${serverlistArray[${menu_selection},protocol]}"
         sleep 2

         if ! ${endless_loop}; then 
            draw_line_colour_set_length_align_right "Portal closed -- goodbye!" "0"
            draw_bot_divider
            exit 0
         fi

         draw_bot_divider

         loop_once="false"
         skip_clear="true"

      elif [[ "${action}" == "cancel" ]]; then
         echo "cancel"; sleep 1 # just for debugging
         loop_once="false"
      fi

      key_stroke="" # Reset keystroke
      if ! ${skip_clear}; then clear; draw_menu main; fi
      skip_clear="false"
   done
}

function do_action {
   local method="${1}"
   ${gui_mode} && fake_loading_screen
   reenable_input

   case ${method} in
      http)
         eval "${BROWSER_NEW_TAB_METHOD}" "${serverlistArray[${menu_selection},hostname]}" 2>/dev/null
         ;;

      ssh)
         expect_ssh_connection
         #"${AUTOINSERT_PASSWORD_EXPECT_SCRIPT}" "${serverlistArray[${menu_selection},password]}" ssh "${serverlistArray[${menu_selection},username]}@${serverlistArray[${menu_selection},hostname]}" -p "${serverlistArray[${menu_selection},port]}"
         ;;

      sftp)
         nautilus sftp://"${serverlistArray[${menu_selection},username]}@${serverlistArray[${menu_selection},hostname]}"/ 2>/dev/null &
         #"${AUTOINSERT_PASSWORD_EXPECT_SCRIPT}" "${serverlistArray[${menu_selection},password]}" | nautilus sftp://"${serverlistArray[${menu_selection},username]}@${serverlistArray[${menu_selection},hostname]}"/ 2>/dev/null &
         #echo "${serverlistArray[${menu_selection},password]}" | nautilus sftp://"${serverlistArray[${menu_selection},username]}@${serverlistArray[${menu_selection},hostname]}"/ 2>/dev/null &
         ;;
   esac

   hide_input
}

function wait_for_input {
    # Disable echo and special characters, set input timeout to 0.2 seconds.
    stty -echo -icanon time 1 || exit $?

    # String containing all keypresses.
    KEYS=""

    # Set field separator to BEL (should not occur in keypresses)
    IFS=$'\a'

    # Input loop.
    while true; do

        # Read more input from keyboard when necessary.
        while read -t 0 ; do
            read -s -r -d "" -N 1 -t 0.2 CHAR && KEYS="$KEYS$CHAR" || break
        done

        # If no keys to process, wait 0.01 seconds and retry.
        if [ -z "$KEYS" ]; then
            sleep 0.01
            return 
        fi

        # Check the first (next) keypress in the buffer.
        case "$KEYS" in
        $'\x1B\x5B\x41'*) # Up
            KEYS="${KEYS##???}"
            key_stroke="up"
            ;;
        $'\x1B\x5B\x42'*) # Down
            KEYS="${KEYS##???}"
            key_stroke="down"
            ;;
        $'\x1B\x5B\x44'*) # Left
            KEYS="${KEYS##???}"
            key_stroke="left"
            ;;
        $'\x1B\x5B\x43'*) # Right
            KEYS="${KEYS##???}"
            key_stroke="right"
            ;;
        $'\x1B\x4F\x48'*|$'\x1b\x5b\x48') # Home
            KEYS="${KEYS##???}"
            ;;
        $'\x1B\x5B\x31\x7E'*) # Home (Numpad)
            KEYS="${KEYS##????}"
            ;;
        $'\x1B\x4F\x46'*|$'\x1b\x5b\x46') # End
            KEYS="${KEYS##???}"
            ;;
        $'\x1B\x5B\x34\x7E'*) # End (Numpad)
            KEYS="${KEYS##????}"
            ;;
        $'\x1B\x5B\x45'*) # 5 (Numpad)
            KEYS="${KEYS#???}"
            ;;
        $'\x1B\x5B\x35\x7e'*) # PageUp
            KEYS="${KEYS##????}"
            key_stroke="page_up"
            ;;
        $'\x1B\x5B\x36\x7e'*) # PageDown
            KEYS="${KEYS##????}"
            key_stroke="page_down"
            ;;
        $'\x1B\x5B\x32\x7e'*) # Insert
            KEYS="${KEYS##????}"
            ;;
        $'\x1B\x5B\x33\x7e'*) # Delete
            KEYS="${KEYS##????}"
            ;;
        $'\r'*) # Return
            KEYS="${KEYS##?}"
            key_stroke="cancel"
            ;;
        $'\n'*) # Enter
            KEYS="${KEYS##?}"
            key_stroke="confirm"
            ;;
        $'\t'*) # Tab
            KEYS="${KEYS##?}"
            #echo "Tab"
            ;;
        $'\x1B') # Esc (without anything following!)
            KEYS="${KEYS##?}"
            key_stroke="cancel"
            #echo "Esc - Quitting"
            #exit 0
            ;;
        $'\x1B'*) # Unknown escape sequences
            echo -n "Unknown escape sequence (${#KEYS} chars): \$'"
            echo -n "$KEYS" | od --width=256 -t x1 | sed -e '2,99 d; s|^[0-9A-Fa-f]* ||; s| |\\x|g; s|$|'"'|"
            KEYS=""
            ;;
        [$'\x01'-$'\x1F'$'\x7F']*) # Consume control characters
            KEYS="${KEYS##?}"
            key_stroke="cancel"
            ;;
        *) # Printable characters.
            KEY="${KEYS:0:1}"
            KEYS="${KEYS#?}"

            case ${KEY} in   
                w) key_stroke="up" ;;
                a) key_stroke="left" ;;
                s) key_stroke="down" ;;
                d) key_stroke="right" ;;
                j) key_stroke="confirm" ;;
                k) key_stroke="cancel" ;;
                :) key_stroke="command" ;;
                *) key_stroke="" ;;
            esac
            ;;
        esac
    done
}
#!/bin/bash
# shellcheck disable=1090,2034,2154,2155

# ██╗   ██╗ █████╗ ██████╗ ██╗ █████╗ ██████╗ ██╗     ███████╗███████╗
# ██║   ██║██╔══██╗██╔══██╗██║██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
# ██║   ██║███████║██████╔╝██║███████║██████╔╝██║     █████╗  ███████╗
# ╚██╗ ██╔╝██╔══██║██╔══██╗██║██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
#  ╚████╔╝ ██║  ██║██║  ██║██║██║  ██║██████╔╝███████╗███████╗███████║
#   ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝
declare -g SCRIPT_NAME="Portal"
declare -g VERSION="beta_v0.6"
declare -g script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 || exit ; pwd -P )"


# ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
# ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
# █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
# ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
# ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
# ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝

function parse_script_input_variables {
   if [[ "$#" -eq 0 ]]; then
      gui_mode="true"
      #exit 0
   fi

   while [[ "$#" -gt 0 ]]; do
      argument="${1}"
      case "${argument}" in
         --gui | -g)
            gui_mode="true"
            ;;

         -h | --help)
            print_help_menu
            exit 0
            ;;
         
         http | ssh | sftp)
            break
            ;;

         -i | --init)
            is_initial_setup="true"
            ;;

         -f | --force)
            force_overwrite="true"
            ;;

         -b | --bash-completion)
            bash_completion
            exit 0
            ;;

         -l | --list)
            list_mode="true"
            ;;

         -s | --search)
            search_mode="true"
            break
            ;;

         -si | --search-ignore-case)
            search_mode="true"
            ignore_case="true"
            break
            ;;

         *)
            echo "Error: Input not an option"
            print_help_menu
            exit 1
            ;;
      esac
      shift
   done
}

function source_functions {
   declare FILES_TO_SOURCE=( "menu_logic.sh" "var.sh" "draw.sh" "load.sh" "utility.sh" "wait_for_input.sh" )

   for file in "${FILES_TO_SOURCE[@]}"; do
      source "${script_path}/functions/${file}"
   done
}

function main {
   parse_script_input_variables "$@"

   if ${is_initial_setup}; then
      initial_setup
      exit 0
   fi

   load_config_file
   get_list_of_csv_files
   load_key_values
   load_csv_file_values
   load_menu_items

   if ${gui_mode}; then
      hide_input
      main_menu
   elif ${list_mode}; then
      draw_connection_list
   elif ${search_mode}; then
      search_keyword="${*:2}"
      draw_connection_list
   else
      menu_selection="${*:2}"
      check_for_connection
      do_action "${1}"
   fi
}


# ███╗   ███╗ █████╗ ██╗███╗   ██╗
# ████╗ ████║██╔══██╗██║████╗  ██║
# ██╔████╔██║███████║██║██╔██╗ ██║
# ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
# ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
# ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝

main "$@"
